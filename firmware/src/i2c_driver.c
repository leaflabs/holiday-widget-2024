#include "i2c_driver.h"

#include <errno.h>

#include "stm32l0xx_hal.h"
#include "uart_logger.h"

/*
 * This is used to allow us to find the encompasing i2c_driver_context struct
 * based on an I2C_HandleTypeDef
 */
#define CONTAINER_OF(ptr, type, field) \
    ({ ((type *)(((char *)(ptr)) - offsetof(type, field))); })

// 1000ms of timeout for blocking I2C transactions
#define TIMEOUT 1000U

int i2c_driver_init(struct i2c_driver_context *i2c_context,
                    I2C_TypeDef *instance) {
    I2C_HandleTypeDef *i2c = &i2c_context->i2c;
    struct i2c_queue_context *queue_context = &i2c_context->queue_context;

    // Set up the i2c handle
    i2c->Instance = instance;
    i2c->Init.Timing =
        0x00100608;  // Based on 100KHz, rise of 400ns and fall of 100ns, Analog
                     // filter enabled. Generated by STM32CubeMX software
    i2c->Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
    if (HAL_I2C_Init(i2c) != HAL_OK) {
        return -EIO;
    }

    HAL_I2CEx_ConfigAnalogFilter(
        i2c, I2C_ANALOGFILTER_ENABLE);  // Don't bother checking these returns
    HAL_I2CEx_ConfigDigitalFilter(i2c,
                                  0);  // because the driver is still functional

    // Make sure all of these are defined to zero so nothing goes wrong
    queue_context->start = 0;
    queue_context->end = 0;
    queue_context->n_elts_used = 0;
    queue_context->current_request = NULL;
    queue_context->i2c_bus_in_use = I2C_FREE;
    return 0;
}

int i2c_device_is_ready(struct i2c_driver_context *i2c_context,
                        uint8_t address) {
    I2C_HandleTypeDef *i2c = &i2c_context->i2c;

    // Attempt 10 times with default timeout.
    return HAL_I2C_IsDeviceReady(i2c, address << 1, 10, TIMEOUT) == HAL_OK;
}

/* Queue operations */

int i2c_enqueue_request(struct i2c_driver_context *i2c_context,
                        struct i2c_request *request) {
    struct i2c_queue_context *queue_context = &i2c_context->queue_context;

    future_set_waiting(&request->future);

    if (queue_context->n_elts_used == QUEUE_LENGTH) {
        return -ENOMEM;
    }

    queue_context->queue[queue_context->end] = request;
    queue_context->end++;
    queue_context->end &= (QUEUE_LENGTH - 1);
    queue_context->n_elts_used++;

    return 0;
}

/*
 * If the current transaction is finished and there is more on the queue,
 * take the first element off the queue and send the transaction.
 */
void i2c_queue_process_one(struct i2c_driver_context *i2c_context) {
    I2C_HandleTypeDef *i2c = &i2c_context->i2c;
    struct i2c_queue_context *queue_context = &i2c_context->queue_context;

    // Verify the queue has items in it to process and that the bus is free
    if (queue_context->n_elts_used > 0 &&
        atomic_load(&queue_context->i2c_bus_in_use) == I2C_FREE) {
        atomic_store(&queue_context->i2c_bus_in_use, I2C_USED);

        struct i2c_request *request =
            queue_context->queue[queue_context->start];
        HAL_StatusTypeDef ret;

        queue_context->start++;
        queue_context->start &= (QUEUE_LENGTH - 1);
        queue_context->n_elts_used--;
        queue_context->current_request = request;

        if (request->action == I2C_READ) {
            ret = HAL_I2C_Mem_Read_IT(i2c, request->address << 1, request->ireg,
                                      1, request->buffer, request->num_bytes);

        } else {
            ret =
                HAL_I2C_Mem_Write_IT(i2c, request->address << 1, request->ireg,
                                     1, request->buffer, request->num_bytes);
        }

        if (ret != HAL_OK) {
            future_error_out(&request->future, -EIO);
        }
    }
}

int i2c_blocking_enqueue(struct i2c_driver_context *i2c_context,
                         struct i2c_request *request) {
    int ret = i2c_enqueue_request(i2c_context, request);
    if (ret != 0) {
        return ret;
    }

    while (future_is_waiting(&request->future)) {
        i2c_queue_process_one(i2c_context);
    }

    return 0;
}

/* Callbacks */

static void complete_callback(I2C_HandleTypeDef *i2c) {
    struct i2c_driver_context *i2c_context =
        CONTAINER_OF(i2c, struct i2c_driver_context, i2c);
    struct i2c_queue_context *queue_context = &i2c_context->queue_context;
    struct i2c_request *current_request = queue_context->current_request;

    if (current_request != NULL) {
        future_finish(&current_request->future);
    }
    atomic_store(&queue_context->i2c_bus_in_use, I2C_FREE);
}

void HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *i2c) {
    complete_callback(i2c);
}

void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *i2c) {
    complete_callback(i2c);
}

void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *i2c) {
    struct i2c_driver_context *i2c_context =
        CONTAINER_OF(i2c, struct i2c_driver_context, i2c);
    struct i2c_queue_context *queue_context = &i2c_context->queue_context;
    struct i2c_request *current_request = queue_context->current_request;

    if (current_request != NULL) {
        future_error_out(&current_request->future, -EIO);
    }
}

void HAL_I2C_AbortCallback(I2C_HandleTypeDef *i2c) {
    struct i2c_driver_context *i2c_context =
        CONTAINER_OF(i2c, struct i2c_driver_context, i2c);
    struct i2c_queue_context *queue_context = &i2c_context->queue_context;
    struct i2c_request *current_request = queue_context->current_request;

    if (current_request != NULL) {
        future_error_out(&current_request->future, -ECONNABORTED);
    }
}
